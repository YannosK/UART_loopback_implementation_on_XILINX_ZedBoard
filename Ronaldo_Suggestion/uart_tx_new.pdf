library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity UART_transmitter is
    Port
    (
        clock      : in  std_logic;
        reset      : in  std_logic;
        Tx_write   : in  std_logic;
        Tx_Data    : in  std_logic_vector(7 downto 0);
        Tx_Ready   : out std_logic;
        TxD        : out std_logic
    );
end UART_transmitter;

architecture Behavioral of UART_transmitter is
    
    component fifo_generator_0 is
      port 
      (
        clk     : IN STD_LOGIC;
        srst    : IN STD_LOGIC;
        din     : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
        wr_en   : IN STD_LOGIC;
        rd_en   : IN STD_LOGIC;
        dout    : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        full    : OUT STD_LOGIC;
        empty   : OUT STD_LOGIC
      );
    end component fifo_generator_0;
    
    type FSM_states is 
    (
        TX_idle,
        TX_send_start_bit,
        TX_data_send,
        TX_send_stop_bit
    );

    signal state_reg    : FSM_states := TX_idle;
	
    signal data_internal: std_logic_vector(7 downto 0); -- internal shift register
    
    signal full_FIFO    : std_logic;                    -- It is '1' if FIFO is completely filled. Connects to 'full' of FIFO
    signal read_FIFO    : std_logic := '0';             -- Set '1' to read from FIFO. Connects to 'rd_en' in FIFO. Only read if not empty
    signal empty_FIFO   : std_logic;                    -- If '1' FIFO is completely empty (no read allowed). Connects to 'empty' in FIFO

    signal TX_Start     : std_logic;                    -- initiate the transmitter when at least one data sample is available
    
    begin

        -----------------------------------------------------------------------------------------------------------------
        -- modules
        -----------------------------------------------------------------------------------------------------------------

        TX_FIFO: fifo_generator_0 port map
                (
                    clk   => clock,
                    srst  => reset,
                    din   => TX_Data,
                    
                    -- write immediately data to FIFO when issued. Save one cycle in the current design
                    wr_en => TX_write,
                    rd_en => read_FIFO,
                    -- write immediately data to shift register. Save one clock cycle. 
                    dout  => data_internal,
                    full  => full_FIFO,
                    empty => empty_FIFO
                );

        -----------------------------------------------------------------------------------------------------------------
        -- signals
        -----------------------------------------------------------------------------------------------------------------

        TX_Ready <= not (full_FIFO);

        -- Since the TX_write will be used to control the FIFO, use the FIFO content as initiation signal.
        -- The transmitter will initiate transmission every time that FIFO has at least one sample
        -- Remember your FIFO is FWFT ! 
        TX_Start <= not (empty_FIFO); 
	
        -----------------------------------------------------------------------------------------------------------------
        -- processes
        -----------------------------------------------------------------------------------------------------------------

--  It is good practice to use separated processes for an FSM.
--  However (this is just my opinion !!) if you can simplify your code
--  do it. I concatenated your driver-state logic processes into a single one.
--  If you do not like it then we will change it into your initial design.

--        state_reg: process (clock, reset) is
--            begin
--                if reset = '1' then
--                    current_state <= TX_idle;
--                else
--                    if rising_edge(clock) then
--                        current_state <= next_state;
--                    end if;
--                end if;
--        end process state_reg;
	
        -- use clock within the sensitivity list of your state logic process to
        -- activate the process on every clock tick.
        
        state_logic: process (reset, clock) is
        
            variable counter : integer := 0;	-- baud counter
            variable bitindex: integer := 0;	-- bit counter within the shift register
            
            begin
            	-- Use asynchronous reset to initialize all signals in case of global reset
            	if reset = '1' then 
            	    state_reg <= TX_idle;
            		TxD <= '1';
            		counter  := 0;	-- this is your baud counter
            		bitindex := 0;  -- this is your bit index for shift register
            		read_FIFO <= '0';
            		
                elsif rising_edge(clock) then 
                    
                    -- make sure the FIFOs read channel is deactivated
                    read_FIFO <= '0';	
                    
                    case state_reg is
                        when TX_idle =>

                            -- when FIFO has at least one data sample then transmit it
                            if TX_start = '1' then
                                counter := 1;   -- take into acount the first clock count that made you start the operation !
                                
                                -- no need to read FIFO here since it is FWFT !
                                -- we do that on another state to save 2 cycles
                                
                                --read_FIFO <= '1';
                                --data_internal <= FIFO_out;        
                                                    
                                state_reg <= TX_send_start_bit;
                    
                            else 
                                TxD 	 <= '1';
                                counter  := 0;
                                bitindex := 0;
                                state_reg <= TX_idle;
                            end if;
                            
                        when TX_send_start_bit =>
                        
                            TxD <= '0';
                            --bitindex := 0;
                            --read_FIFO <= '0';
                        
                            if counter = 15 then
                                counter := 0;
                                state_reg <= TX_data_send;
                            else
                                counter := counter + 1;
                                state_reg <= TX_send_start_bit;
                            end if;
                            
                        when TX_data_send =>
                           TxD <= data_internal(bitindex); -- transmit the current bit
                           
                           if counter = 15 then
                           
                                counter := 0;
                                
                                if bitindex < 7 then
                                    bitindex := bitindex + 1;
                                    state_reg <= TX_data_send;
                                    
                                else
                                    bitindex := 0;
                                    
                                    -- here you need to read the next data sample from FIFO
                                    -- remember your FIFO is FWFT!
                                    read_FIFO <= '1';
                                
                                    state_reg <= TX_send_stop_bit;
                                end if;
                           else
                                counter := counter + 1;
                                state_reg <= TX_data_send;
                           end if;
                           
                        when TX_send_stop_bit =>
                            
                            read_FIFO <= '0';
                            TxD <= '1';
                            bitindex := 0;
                            
                            if counter = 15 then 
                                counter := 0;
                                state_reg <= TX_idle;
                            else
                                counter := counter + 1;
                                state_reg <= TX_send_stop_bit;
                            end if;
                        
                        when others =>
                            state_reg <= TX_idle;
                    end case;
            end if;
        end process state_logic;

end Behavioral;
